const fs = require("fs");
const ora = require("ora");
const path = require("path");
const chalk = require("chalk");
const webpack = require("webpack");
const { getWebpackConfig, getProjectRoot } = require("./index");
const { ConfigPrinter, logBuildAssets } = require("../utils/print");
const { resolveConfigPath, validateConfig } = require("./utils");
import type { Configuration, Stats, StatsError } from "webpack";

interface BuildOptions {
  config?: string; // é…ç½®æ–‡ä»¶è·¯å¾„
  analyze?: boolean; // æ˜¯å¦å¼€å¯æ‰“åŒ…åˆ†æ
  debug?: boolean; // æ˜¯å¦å¼€å¯è°ƒè¯•æ¨¡å¼
}

async function buildProject(options: BuildOptions) {
  // 1. è·å–é…ç½®æ–‡ä»¶è·¯å¾„
  const configPath = resolveConfigPath(options.config);
  // 2. è·å–webpacké…ç½®
  const config = await getWebpackConfig({
    mode: "production",
    configPath,
  });
  // 3. éªŒè¯é…ç½®
  validateConfig(config);
  // 4. æ‰“å°é…ç½®ï¼ˆè°ƒè¯•æ¨¡å¼ä¸‹ï¼‰
  if (options.debug) {
    ConfigPrinter.printWebpackConfig(config);
    const outputPath = path.resolve(getProjectRoot(), "webpack.config.debugfile.js");
    fs.writeFileSync(outputPath, `// This is a debug file generated by build command\nmodule.exports = ${JSON.stringify(config, null, 2)}`, "utf-8");
    console.log(chalk.gray(`Debug config has been written to ${outputPath}`));
  }
  // 5. æ‰§è¡Œæ„å»º
  await runBuild(config);
}

function runBuild(config: Configuration): Promise<void> {
  return new Promise((resolve, reject) => {
    const compiler = webpack(config);
    // å¼€å§‹æ„å»º
    const spinner = ora({
      text: chalk.cyan("æ­£åœ¨æ„å»ºé¡¹ç›®..."),
      color: "cyan",
    }).start();

    const startTime = Date.now();
    compiler.run((err: Error | null, stats: Stats | undefined) => {
      // åœæ­¢ spinner
      spinner.stop();
      compiler.close((closeErr: Error | null) => {
        if (closeErr) {
          console.error(chalk.yellow("è­¦å‘Š: Compiler å…³é—­æ—¶å‘ç”Ÿé”™è¯¯"), closeErr);
        }
      });

      if (err) {
        console.error(chalk.red("âŒ æ„å»ºå¤±è´¥:"), err.message);
        reject(err);
        return;
      }

      if (!stats) {
        reject(new Error("æ²¡æœ‰ç”Ÿæˆæ„å»ºç»Ÿè®¡ä¿¡æ¯"));
        return;
      }
      // å¤„ç†æ„å»ºç»“æœ
      handleBuildResult(stats);
      // æ£€æŸ¥æ„å»ºæ˜¯å¦æœ‰é”™è¯¯
      if (stats.hasErrors()) {
        reject(new Error("æ„å»ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯"));
        return;
      }
      const endTime = Date.now();
      // æ·»åŠ å®ŒæˆåŠ¨ç”»å’Œä¿¡æ¯
      console.log("\n" + chalk.green("âœ¨ æ„å»ºæˆåŠŸï¼"), chalk.cyan("â±ï¸  æ„å»ºç”¨æ—¶ï¼š") + chalk.yellow(`${(endTime - startTime) / 1000}s`));
      resolve();
    });
  });
}

function handleBuildResult(stats: Stats): void {
  // è¾“å‡ºæ„å»ºä¿¡æ¯
  const statsOutput = stats.toString({
    colors: true,
    modules: false,
    children: false,
    chunks: false,
    chunkModules: false,
    entrypoints: false,
  });

  // è¾“å‡ºè­¦å‘Šå’Œé”™è¯¯
  if (stats.hasWarnings()) {
    console.log(chalk.yellow("\nâš ï¸  æ„å»ºè­¦å‘Š:\n"));
    const info = stats.toJson();
    info.warnings?.forEach((warning: StatsError) => {
      console.log(chalk.yellow(warning.message || warning));
    });
  }

  if (stats.hasErrors()) {
    console.log(chalk.red("\nğŸš¨ æ„å»ºé”™è¯¯:\n"));
    const info = stats.toJson();
    info.errors?.forEach((error: StatsError) => {
      console.log(chalk.red(error.message || error));
    });
  }
  // è¾“å‡ºæ„å»ºç»Ÿè®¡ä¿¡æ¯
  console.log(statsOutput);
  // è¾“å‡ºæ„å»ºèµ„æºä¿¡æ¯
  const info = stats.toJson({
    assets: true,
    chunks: false,
    modules: false,
  });
  logBuildAssets(info);
}

module.exports = {
  buildProject,
};
